# STL 라이브러리

이 글에서는 **C++** 의 **STL 라이브러리**에 대해서 다룬다.
**STL 라이브러리**는 **C++** 의 표준 라이브러리로, 표준에 포함된 이후로는 따로 STL 이라고 나누지는 않지만, 그대로 STL 이라고 불리고 있다.
쉽게 STL을 표현하자면, **자료를 저장하는 여러 방법들을 우리가 원하는 타입으로 사용할 수 있게 일반화 하여 만들어놓은 라이브러리** 라고 생각 할 수 있다.

## STL의 구성

STL은 크게 나누어서 다음 3가지로 구성되어 있다.
**Container** : 자료를 저장하는 방식들
**Iterator** : Container의 각 항목들을 순회하는 방법을 추상화
**Algorithm** : 자료의 집합에 대한 작업의 정의

## Container 종류
각자 Container의 종류에 대한 특징은 다음과 같다.
### Vector
**저장할 데이터의 양이 가변적인 배열**이다.
#### 1. 메모리에서 연속적인 공간을 할당받는다.
**메모리에 연속적으로 할당**이 되어있기 때문에, 몇번 째 원소를 읽고싶다, 같은 **ramdom access 가 가능**하다.
#### 2. 크기가 가변적으로 변한다.
배열과는 다르게 **크기가 가변적**이다. 메모리에서 할당 된 크기를 **모두 채울 경우에는 새로운 연속된 메모리공간을 다시 할당**받고 여기로 기존 값들을 옮기는 방식으로 크기를 확장한다.
간단하게 설명하면, 처음 선언 때 16칸의 배열이였는데 17번째 원소가 삽입이 된다면, 32칸의 새로운 공간을 할당받고 기존의 16칸을 이 새로운 32칸에 모두 옮긴 뒤 17번째 원소를 삽입한다.
**이때의 오버헤드가 크기 때문에, 큰 공간을 써야 할 때에는 초기할당값을 크게 잡아주는 것이 좋다.**

### Deque
**저장할 양이 가변적이면서 양쪽에서 모두 push, pop이 가능**한 구조
#### 1. 메모리에서 연속적인 공간을 할당받는다.
**vector와 마찬가지로 메모리에서 연속적인 공간을 할당**받는다. **ramdom access 가 가능**하다. 하지만 방식이 vector와 약간 다르다.
#### 2. 크기가 가변적으로 변한다.
배열과는 다르게 **크기가 가변적**이다. 가변적으로 크기를 바꾸는 방식은 vector와 약간 다른데, 실제로는 연속된 메모리 **여러블록을 할당하여 저장**하고, 실제 사용자가 **보기로는 하나의 메모리 공간**에 할당된 것 처럼 보이게 한다.
#### 3. queue 와 stack 을 합친 형태로 생각할 수 있다.
deque 는 **double-ended queue**의 줄임말로, **양쪽 끝에서 삽입과 삭제가 일어날 때** 아주 효율적인 컨테이너이다.

### Vector VS Deque
둘의 기능은 비슷하지만, 크기를 가변적으로 변경시키는 방식의 차이로 각자 차이가 존재한다.
vector의 경우에는 할당된 크기를 넘었을 때 **재할당되는 때에 전체 복사가 일어나는 부분**이 단점이 된다.
deque는 random access는 가능하지만, **실제로는 연속된 하나의 메모리 블럭이 아니기 때문**에, **포인터 연산이 불가능**하다는 단점이 있다.

### List
**저장할 양이 가변적이면서 모든 부분에서 삽입과 삭제가 효율적으로 가능**한 구조
#### 1. 연속된 공간을 기반으로 하지 않고 node를 기반으로 한다.
vector와는 다르게 연속된 메모리를 할당받지 않는다. 하나하나의 값은 각자 다른 메모리의 위치에 존재하고, 각각의 값이 자신의 앞 뒤 값들의 주소를 저장한다.
#### 2. 삽입과 삭제가 효율적이다.
vector, deque는 정도의 차이는 있지만 그 중간에 값을 삽입하거나 삭제할 때에 모든 값을 한칸씩 밀고 값을 저장시키기 때문에 많은 시간이 소모된다.
list는 중간에 삽입과 삭제가 일어나도 **해당 노드의 전후의 주소값만 변경해주면 되기 때문**에 빠르게 이루어진다.

### Vector VS List
* vector 를 사용할 때 
> vector는 일반적으로 **크기가 가변적인 배열**을 사용할 때 많이 사용된다. 메모리 주소를 기반으로 한 **ramdom access 가 가능**하다는 점도 있지만, **캐시의 지역성**때문에 한 블럭에 자료들이 모여있는 vector가 일반적인 성능이 더 좋다. 중간에 삽입과 삭제를 할 일이 많이 없다면 vector를 사용하는것이 낫다.
* list 를 사용할 때
> list는 **중간에 삽입과 삭제가 많이 일어나는 작업**을 해야할 때 사용하는 것이 좋다. 하지만 그 자료의 수가 수백개 정도로 크지 않다면 vector를 사용하는 것이 더 효율적이다.

### Map
map은 겉로 보기에는 배열은 배열인데 식별자가 숫자가 아닌 값이 올 수 있는 배열의 모습이라고 할 수 있다. 
>(map_test["text_data"])같은 식으로 식별가능)  

map은 다음과 같은 특징을 가진다.
#### 1. tree구조로 저장이 된다.
배열과 가장 크게 다른점이다. **tree형식** --정확히는 tree 종류중 하나인 레드블랙트리-- **으로 저장**이 되며, **내부에서 자동으로 정렬**이 된다. 자동으로 정렬이 되기때문에, **많은 자료에 대해 검색할 때 좋은 성능**을 보여준다.  
그러나 자동으로 정렬이 된다는 것은, **데이터 삽입시에 삽입 이외에 정렬하는 과정이 더 필요**하다는 것을 의미한다. 그러므로 삽입과 삭제가 자주 일어나는 경우에는 좋지 않은 성능을 보여준다.
#### 2. key와 value의 쌍으로 저장이 된다.  
아래에 기술할 set과의 차이점은 key에 value값이 존재한다는 것이다.
#### 3. key의 값은 중복되는 값이 없다.
key로 들어가는 값은 중복되는 값이 들어갈 수 없다.

### Set
map에서 value가 빠진 형태라고 보면 쉽다.
#### 1. tree구조로 저장이 된다.
map과 같이, tree 형태로 저장이 된다. **내부에서 자동으로 정렬**이 된다. 자동으로 정렬이 되기때문에, **많은 자료에 대해 검색할 때 좋은 성능**을 보여준다.  
그러나 자동으로 정렬이 된다는 것은, **데이터 삽입시에 삽입 이외에 정렬하는 과정이 더 필요**하다는 것을 의미한다. 그러므로 삽입과 삭제가 자주 일어나는 경우에는 좋지 않은 성능을 보여준다.
#### 2. key의 뭉치와 같은 형태로 저장이 된다.
map과의 차이점은 key에 해당하는 value값을 저장하지 않고, key 값만 있다는 것이다.
#### 3. key의 값은 중복되는 값이 없다.
key로 들어가는 값은 중복되는 값이 들어갈 수 없다.

### Set VS Map
set과 map의 차이점은 위에 기술되어 있듯 value값이 존재하는가 이다. 
다른 활용방법의 차이도 있지만, 그로 인해 생기는 차이중 하나는 
* 키 값의 유무를 판단하는 set
* 키에 대한 검색을 하는 map  

같은 개념이다.

### stack
가장 마지막에 들어간 값이 제일 먼저 나오는 형태이다.  

### queue
들어오는 순서대로 나오는 형태이다.

## Algorithm 종류
