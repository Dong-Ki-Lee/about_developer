# 입출력 함수 정리

C/C++에는 다양한 입출력 함수가 존재한다.

C 에서 주로 사용하는 scanf, printf 와 C++에서 추가된 cin, cout 등을 제외하고도 많은 입출력이 존재한다.

이 문서에서는 각 함수의 특징에 대해서 정리하고자 한다.



## C 표준입출력

C의 표준입출력은 stdio.h 헤더에 정의되어 있으며, stdio 자체가 standard input output의 약자이다.

### scanf

#### 함수 형식

```C
int scanf ( const char * format, argument-pointer-list);

// example
int temp;
scanf("%d", &temp);

int temp1, temp2;
scanf("%d%d", temp1, temp2);
```

scanf는 첫번째 인자로 받을 데이터의 형태를 받고, 두번째 인자부터 받을 변수의 주소값을 받는다.



#### 첫번 째 인자 옵션

> % * width modifiers type

올수 있는 것을 차례대로 나열하였다.

1. %뒤에 *를 붙일경우 이 입력값은 무시된다.

   ```C
   int temp;
   scanf("%*d%d", &temp);
   print(temp);
   
   >>> 2 3
   3
   ```

   *이 붙은 첫번째 입력값이 무시된다.

2. width 는 읽어들일 최대 문자수를 정하고 싶을 때 지정한다.

   ```C
   scanf("%10s", string);
   ```

   위처럼 사용하면, 최대 10개 문자까지 읽어와 저장하게 된다.

   오버플로우 방지를 위해서도 사용될 수 있다.

3. modifier 는 숫자형의 데이터를 읽어올 때 데이터의 크기를 설정할 수 있다.

4. type 에는 읽어들일 데이터의 형태를 지정한다.

#### 동작 방식

키보드로 입력받은 값을 scanf가 바로 읽는것이 아닌, 입력되는 값을 먼저 버퍼라는 메모리에 저장한 뒤에 scanf는 그 버퍼를 읽어서 처리하게 된다.

값을 입력받을 때 이 버퍼에서 문제가 생길 수 있다.



#### 버퍼에서 생기는 문제

CLI 환경에서 입력할 때, 입력의 마무리를 개행문자 '\n'(enter 키)로 하게 되는데, 버퍼에는 이 '\n'까지 저장이 된다.

하지만 다음 코드의 경우 이 버퍼에 저장된 '\n'가 문제가 될 수 있는데,

```C
#include <stdio.h>

int main() {
    int i;
    char c;
    scanf("%d", &i);
    scanf("%c", &c);
    
    return 0;
}

>>> 3
>>> k
```

위 코드의 경우 아래처럼 3, c를 삽입할 경우 기대하는 동작은 i에 3이, c에 k가 삽입되는 것이다.

하지만 이 경우에 먼저 실행된 scanf가 '\n' 전까지 입력을 받기때문에, 두번째 scanf에서는 버퍼에 남아있던 \n를 받아오게 된다



#### 버퍼 문제 해결 방법

1. fflush 함수 사용하기 ( 사용하지 않는 것이 좋다 )

   fflush 함수는 원래 버퍼에 남아있는 데이터를 꺼내고 비우는 역할을 한다. 버퍼가 비워지는 시점이 OS마다 다르기 때문에, OS별로 동일한 동작을 보장하기 위해 사용하기도 하는 함수이다.

   stdio.h에 선언되어 있기때문에 C 표준 함수여서 사용할 수도 있겠지만, fflush() 함수로 입력 버퍼를 비우는건 좋은 해결방법은 아니다.

   좋은 해결방법이 아닌 이유로는, 표준으로 정해진 fflush 함수의 입력이 출력 스트림 버퍼에 대해서만 표준으로 정해져 있다는 것이다. 출력 버퍼는 표준이기 때문에 동일한 동작을 보장하겠지만, 입력 버퍼를 넣을 경우에는 표준에 정의되지 않았기 때문에 OS별로, 컴파일러 별로 다른 동작을 할 수 있다. OS에 따라서 동작을 하기도하고, 하지 않기도 한다.

2. getchar 함수  사용하기

   입력과 입력 사이에 문자 하나를 읽어 버리는 방식으로, \n을 읽어서 그냥 버리고싶을 때 사용한다.

3. rewind 함수 사용하기

   입력받은 버퍼를 초기화 하는 방법으로 사용할 수 있다.

4. scanf 함수 옵션 이용

   scanf("%*c") 처럼 사용해서 \n를 읽어서 버리도록 할 수도 있고, scanf(" %c") 처럼 사용해서 구분자 이후를 읽게 만들수도 있다.



#### scanf_s 의 차이점

scanf 에서 문자열을 입력받을 때, 입력 범위를 정해주지 않으면 버퍼의 크기를 넘어서는 문자열이 입력 된 경우 버퍼 오버플로우가 일어나는 문제가 있다. 이 문제를 해결하기 위해서, 문자열 입력시에 추가적으로 입력 버퍼의 크기까지 인자로 받아 오버플로우의 위험성을 없앤 것이 scanf_s 함수 이다.



### printf

#### 함수 형식

```C
int printf(const char *format, argument-list);
```

stdout에 일련의 문자와 값의 형식을 지정하고 출력한다.

#### 첫번 째 인자 옵션

> % flags width precision 인수 크기 type

#### 주의점

scanf와 달리 인자로 주소값이 아닌 변수명을 넣는다.



### getchar

#### 함수 형식

```C
int getchar(void);

int i;
i = getchar();

char c;
c = getchar();
```

stdin 에서 한 문자를 가져오는 함수이고, 읽어들인 문자를 아스키 int 값으로 반환한다.

예를들어, 위 예제코드에 a를 입력하고, printf 로 i를 출력하면 97이 출력된다. 숫자도 아스키 코드로 들어가기 때문에 입력받는 값이 아스키 코드라는것을 생각해야 한다.



### putchar

#### 함수 형식

```C
int putchar(int i);

int i;
i = getchar();
char c;
c = getchar();

putchar(i);
putchar(c);
```

stdout에 한 문자를 쓰는 함수이고, 아스키 코드 숫자를 입력으로 받아 해당 아스키 코드에 해당하는 문자를 출력한다.

위처럼 char 에 값을 받아 출력해도 char에 아스키코드 숫자값이 저장되므로 동일하게 동작한다.

return 값은 int 값인데, 오류가 없다면 표준 출력에 쓰여진 아스키코드 값이 반환되고, 오류가 발생하면 EOF가 반환된다.



## C++ 표준입출력

